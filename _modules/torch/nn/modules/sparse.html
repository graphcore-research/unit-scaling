

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>torch.nn.modules.sparse &mdash; unit-scaling  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />

  
    <link rel="shortcut icon" href="../../../../_static/scales.png"/>
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            unit-scaling
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../user_guide.html">1. User guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../limitations.html">2. Limitations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../api_reference.html">3. API reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">unit-scaling</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">torch.nn.modules.sparse</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for torch.nn.modules.sparse</h1><div class="highlight"><pre>
<span></span><span class="c1"># mypy: allow-untyped-defs</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>

<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">Tensor</span>
<span class="kn">from</span> <span class="nn">torch.nn</span> <span class="kn">import</span> <span class="n">functional</span> <span class="k">as</span> <span class="n">F</span><span class="p">,</span> <span class="n">init</span>
<span class="kn">from</span> <span class="nn">torch.nn.parameter</span> <span class="kn">import</span> <span class="n">Parameter</span>

<span class="kn">from</span> <span class="nn">.module</span> <span class="kn">import</span> <span class="n">Module</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Embedding&quot;</span><span class="p">,</span> <span class="s2">&quot;EmbeddingBag&quot;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">Embedding</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;A simple lookup table that stores embeddings of a fixed dictionary and size.</span>

<span class="sd">    This module is often used to store word embeddings and retrieve them using indices.</span>
<span class="sd">    The input to the module is a list of indices, and the output is the corresponding</span>
<span class="sd">    word embeddings.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_embeddings (int): size of the dictionary of embeddings</span>
<span class="sd">        embedding_dim (int): the size of each embedding vector</span>
<span class="sd">        padding_idx (int, optional): If specified, the entries at :attr:`padding_idx` do not contribute to the gradient;</span>
<span class="sd">                                     therefore, the embedding vector at :attr:`padding_idx` is not updated during training,</span>
<span class="sd">                                     i.e. it remains as a fixed &quot;pad&quot;. For a newly constructed Embedding,</span>
<span class="sd">                                     the embedding vector at :attr:`padding_idx` will default to all zeros,</span>
<span class="sd">                                     but can be updated to another value to be used as the padding vector.</span>
<span class="sd">        max_norm (float, optional): If given, each embedding vector with norm larger than :attr:`max_norm`</span>
<span class="sd">                                    is renormalized to have norm :attr:`max_norm`.</span>
<span class="sd">        norm_type (float, optional): The p of the p-norm to compute for the :attr:`max_norm` option. Default ``2``.</span>
<span class="sd">        scale_grad_by_freq (bool, optional): If given, this will scale gradients by the inverse of frequency of</span>
<span class="sd">                                                the words in the mini-batch. Default ``False``.</span>
<span class="sd">        sparse (bool, optional): If ``True``, gradient w.r.t. :attr:`weight` matrix will be a sparse tensor.</span>
<span class="sd">                                 See Notes for more details regarding sparse gradients.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        weight (Tensor): the learnable weights of the module of shape (num_embeddings, embedding_dim)</span>
<span class="sd">                         initialized from :math:`\mathcal{N}(0, 1)`</span>

<span class="sd">    Shape:</span>
<span class="sd">        - Input: :math:`(*)`, IntTensor or LongTensor of arbitrary shape containing the indices to extract</span>
<span class="sd">        - Output: :math:`(*, H)`, where `*` is the input shape and :math:`H=\text{embedding\_dim}`</span>

<span class="sd">    .. note::</span>
<span class="sd">        Keep in mind that only a limited number of optimizers support</span>
<span class="sd">        sparse gradients: currently it&#39;s :class:`optim.SGD` (`CUDA` and `CPU`),</span>
<span class="sd">        :class:`optim.SparseAdam` (`CUDA` and `CPU`) and :class:`optim.Adagrad` (`CPU`)</span>

<span class="sd">    .. note::</span>
<span class="sd">        When :attr:`max_norm` is not ``None``, :class:`Embedding`&#39;s forward method will modify the</span>
<span class="sd">        :attr:`weight` tensor in-place. Since tensors needed for gradient computations cannot be</span>
<span class="sd">        modified in-place, performing a differentiable operation on ``Embedding.weight`` before</span>
<span class="sd">        calling :class:`Embedding`&#39;s forward method requires cloning ``Embedding.weight`` when</span>
<span class="sd">        :attr:`max_norm` is not ``None``. For example::</span>

<span class="sd">            n, d, m = 3, 5, 7</span>
<span class="sd">            embedding = nn.Embedding(n, d, max_norm=1.0)</span>
<span class="sd">            W = torch.randn((m, d), requires_grad=True)</span>
<span class="sd">            idx = torch.tensor([1, 2])</span>
<span class="sd">            a = embedding.weight.clone() @ W.t()  # weight must be cloned for this to be differentiable</span>
<span class="sd">            b = embedding(idx) @ W.t()  # modifies weight in-place</span>
<span class="sd">            out = (a.unsqueeze(0) + b.unsqueeze(1))</span>
<span class="sd">            loss = out.sigmoid().prod()</span>
<span class="sd">            loss.backward()</span>

<span class="sd">    Examples::</span>

<span class="sd">        &gt;&gt;&gt; # an Embedding module containing 10 tensors of size 3</span>
<span class="sd">        &gt;&gt;&gt; embedding = nn.Embedding(10, 3)</span>
<span class="sd">        &gt;&gt;&gt; # a batch of 2 samples of 4 indices each</span>
<span class="sd">        &gt;&gt;&gt; input = torch.LongTensor([[1, 2, 4, 5], [4, 3, 2, 9]])</span>
<span class="sd">        &gt;&gt;&gt; # xdoctest: +IGNORE_WANT(&quot;non-deterministic&quot;)</span>
<span class="sd">        &gt;&gt;&gt; embedding(input)</span>
<span class="sd">        tensor([[[-0.0251, -1.6902,  0.7172],</span>
<span class="sd">                 [-0.6431,  0.0748,  0.6969],</span>
<span class="sd">                 [ 1.4970,  1.3448, -0.9685],</span>
<span class="sd">                 [-0.3677, -2.7265, -0.1685]],</span>

<span class="sd">                [[ 1.4970,  1.3448, -0.9685],</span>
<span class="sd">                 [ 0.4362, -0.4004,  0.9400],</span>
<span class="sd">                 [-0.6431,  0.0748,  0.6969],</span>
<span class="sd">                 [ 0.9124, -2.3616,  1.1151]]])</span>


<span class="sd">        &gt;&gt;&gt; # example with padding_idx</span>
<span class="sd">        &gt;&gt;&gt; embedding = nn.Embedding(10, 3, padding_idx=0)</span>
<span class="sd">        &gt;&gt;&gt; input = torch.LongTensor([[0, 2, 0, 5]])</span>
<span class="sd">        &gt;&gt;&gt; embedding(input)</span>
<span class="sd">        tensor([[[ 0.0000,  0.0000,  0.0000],</span>
<span class="sd">                 [ 0.1535, -2.0309,  0.9315],</span>
<span class="sd">                 [ 0.0000,  0.0000,  0.0000],</span>
<span class="sd">                 [-0.1655,  0.9897,  0.0635]]])</span>

<span class="sd">        &gt;&gt;&gt; # example of changing `pad` vector</span>
<span class="sd">        &gt;&gt;&gt; padding_idx = 0</span>
<span class="sd">        &gt;&gt;&gt; embedding = nn.Embedding(3, 3, padding_idx=padding_idx)</span>
<span class="sd">        &gt;&gt;&gt; embedding.weight</span>
<span class="sd">        Parameter containing:</span>
<span class="sd">        tensor([[ 0.0000,  0.0000,  0.0000],</span>
<span class="sd">                [-0.7895, -0.7089, -0.0364],</span>
<span class="sd">                [ 0.6778,  0.5803,  0.2678]], requires_grad=True)</span>
<span class="sd">        &gt;&gt;&gt; with torch.no_grad():</span>
<span class="sd">        ...     embedding.weight[padding_idx] = torch.ones(3)</span>
<span class="sd">        &gt;&gt;&gt; embedding.weight</span>
<span class="sd">        Parameter containing:</span>
<span class="sd">        tensor([[ 1.0000,  1.0000,  1.0000],</span>
<span class="sd">                [-0.7895, -0.7089, -0.0364],</span>
<span class="sd">                [ 0.6778,  0.5803,  0.2678]], requires_grad=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__constants__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;num_embeddings&quot;</span><span class="p">,</span>
        <span class="s2">&quot;embedding_dim&quot;</span><span class="p">,</span>
        <span class="s2">&quot;padding_idx&quot;</span><span class="p">,</span>
        <span class="s2">&quot;max_norm&quot;</span><span class="p">,</span>
        <span class="s2">&quot;norm_type&quot;</span><span class="p">,</span>
        <span class="s2">&quot;scale_grad_by_freq&quot;</span><span class="p">,</span>
        <span class="s2">&quot;sparse&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">num_embeddings</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">embedding_dim</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">padding_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
    <span class="n">max_norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="n">norm_type</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">scale_grad_by_freq</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">weight</span><span class="p">:</span> <span class="n">Tensor</span>
    <span class="n">freeze</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">sparse</span><span class="p">:</span> <span class="nb">bool</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">num_embeddings</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">embedding_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">padding_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">max_norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">norm_type</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
        <span class="n">scale_grad_by_freq</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">sparse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_freeze</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">factory_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;device&quot;</span><span class="p">:</span> <span class="n">device</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">dtype</span><span class="p">}</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_embeddings</span> <span class="o">=</span> <span class="n">num_embeddings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">embedding_dim</span> <span class="o">=</span> <span class="n">embedding_dim</span>
        <span class="k">if</span> <span class="n">padding_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">padding_idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">padding_idx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_embeddings</span>
                <span class="p">),</span> <span class="s2">&quot;Padding_idx must be within num_embeddings&quot;</span>
            <span class="k">elif</span> <span class="n">padding_idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">padding_idx</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">num_embeddings</span>
                <span class="p">),</span> <span class="s2">&quot;Padding_idx must be within num_embeddings&quot;</span>
                <span class="n">padding_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_embeddings</span> <span class="o">+</span> <span class="n">padding_idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_idx</span> <span class="o">=</span> <span class="n">padding_idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_norm</span> <span class="o">=</span> <span class="n">max_norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm_type</span> <span class="o">=</span> <span class="n">norm_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_grad_by_freq</span> <span class="o">=</span> <span class="n">scale_grad_by_freq</span>
        <span class="k">if</span> <span class="n">_weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_embeddings</span><span class="p">,</span> <span class="n">embedding_dim</span><span class="p">),</span> <span class="o">**</span><span class="n">factory_kwargs</span><span class="p">),</span>
                <span class="n">requires_grad</span><span class="o">=</span><span class="ow">not</span> <span class="n">_freeze</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset_parameters</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">_weight</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span>
                <span class="n">num_embeddings</span><span class="p">,</span>
                <span class="n">embedding_dim</span><span class="p">,</span>
            <span class="p">],</span> <span class="s2">&quot;Shape of weight does not match num_embeddings and embedding_dim&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">_weight</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="ow">not</span> <span class="n">_freeze</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span> <span class="o">=</span> <span class="n">sparse</span>

    <span class="k">def</span> <span class="nf">reset_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">init</span><span class="o">.</span><span class="n">normal_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fill_padding_idx_with_zero</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_fill_padding_idx_with_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">padding_idx</span><span class="p">]</span><span class="o">.</span><span class="n">fill_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">embedding</span><span class="p">(</span>
            <span class="nb">input</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">padding_idx</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_norm</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm_type</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_grad_by_freq</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">extra_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{num_embeddings}</span><span class="s2">, </span><span class="si">{embedding_dim}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, padding_idx=</span><span class="si">{padding_idx}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, max_norm=</span><span class="si">{max_norm}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_type</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, norm_type=</span><span class="si">{norm_type}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_grad_by_freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, scale_grad_by_freq=</span><span class="si">{scale_grad_by_freq}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, sparse=True&quot;</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>

<div class="viewcode-block" id="Embedding.from_pretrained">
<a class="viewcode-back" href="../../../../generated/unit_scaling.Embedding.html#unit_scaling.Embedding.from_pretrained">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_pretrained</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">embeddings</span><span class="p">,</span>
        <span class="n">freeze</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">padding_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">max_norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">norm_type</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
        <span class="n">scale_grad_by_freq</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Create Embedding instance from given 2-dimensional FloatTensor.</span>

<span class="sd">        Args:</span>
<span class="sd">            embeddings (Tensor): FloatTensor containing weights for the Embedding.</span>
<span class="sd">                First dimension is being passed to Embedding as ``num_embeddings``, second as ``embedding_dim``.</span>
<span class="sd">            freeze (bool, optional): If ``True``, the tensor does not get updated in the learning process.</span>
<span class="sd">                Equivalent to ``embedding.weight.requires_grad = False``. Default: ``True``</span>
<span class="sd">            padding_idx (int, optional): If specified, the entries at :attr:`padding_idx` do not contribute to the gradient;</span>
<span class="sd">                                         therefore, the embedding vector at :attr:`padding_idx` is not updated during training,</span>
<span class="sd">                                         i.e. it remains as a fixed &quot;pad&quot;.</span>
<span class="sd">            max_norm (float, optional): See module initialization documentation.</span>
<span class="sd">            norm_type (float, optional): See module initialization documentation. Default ``2``.</span>
<span class="sd">            scale_grad_by_freq (bool, optional): See module initialization documentation. Default ``False``.</span>
<span class="sd">            sparse (bool, optional): See module initialization documentation.</span>

<span class="sd">        Examples::</span>

<span class="sd">            &gt;&gt;&gt; # FloatTensor containing pretrained weights</span>
<span class="sd">            &gt;&gt;&gt; weight = torch.FloatTensor([[1, 2.3, 3], [4, 5.1, 6.3]])</span>
<span class="sd">            &gt;&gt;&gt; embedding = nn.Embedding.from_pretrained(weight)</span>
<span class="sd">            &gt;&gt;&gt; # Get embeddings for index 1</span>
<span class="sd">            &gt;&gt;&gt; input = torch.LongTensor([1])</span>
<span class="sd">            &gt;&gt;&gt; # xdoctest: +IGNORE_WANT(&quot;non-deterministic&quot;)</span>
<span class="sd">            &gt;&gt;&gt; embedding(input)</span>
<span class="sd">            tensor([[ 4.0000,  5.1000,  6.3000]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">embeddings</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="p">),</span> <span class="s2">&quot;Embeddings parameter is expected to be 2-dimensional&quot;</span>
        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">embeddings</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">embedding</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">num_embeddings</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span>
            <span class="n">embedding_dim</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span>
            <span class="n">_weight</span><span class="o">=</span><span class="n">embeddings</span><span class="p">,</span>
            <span class="n">_freeze</span><span class="o">=</span><span class="n">freeze</span><span class="p">,</span>
            <span class="n">padding_idx</span><span class="o">=</span><span class="n">padding_idx</span><span class="p">,</span>
            <span class="n">max_norm</span><span class="o">=</span><span class="n">max_norm</span><span class="p">,</span>
            <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span><span class="p">,</span>
            <span class="n">scale_grad_by_freq</span><span class="o">=</span><span class="n">scale_grad_by_freq</span><span class="p">,</span>
            <span class="n">sparse</span><span class="o">=</span><span class="n">sparse</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">embedding</span></div>



<span class="k">class</span> <span class="nc">EmbeddingBag</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Compute sums or means of &#39;bags&#39; of embeddings, without instantiating the intermediate embeddings.</span>

<span class="sd">    For bags of constant length, no :attr:`per_sample_weights`, no indices equal to :attr:`padding_idx`,</span>
<span class="sd">    and with 2D inputs, this class</span>

<span class="sd">        * with ``mode=&quot;sum&quot;`` is equivalent to :class:`~torch.nn.Embedding` followed by ``torch.sum(dim=1)``,</span>
<span class="sd">        * with ``mode=&quot;mean&quot;`` is equivalent to :class:`~torch.nn.Embedding` followed by ``torch.mean(dim=1)``,</span>
<span class="sd">        * with ``mode=&quot;max&quot;`` is equivalent to :class:`~torch.nn.Embedding` followed by ``torch.max(dim=1)``.</span>

<span class="sd">    However, :class:`~torch.nn.EmbeddingBag` is much more time and memory efficient than using a chain of these</span>
<span class="sd">    operations.</span>

<span class="sd">    EmbeddingBag also supports per-sample weights as an argument to the forward</span>
<span class="sd">    pass. This scales the output of the Embedding before performing a weighted</span>
<span class="sd">    reduction as specified by ``mode``. If :attr:`per_sample_weights` is passed, the</span>
<span class="sd">    only supported ``mode`` is ``&quot;sum&quot;``, which computes a weighted sum according to</span>
<span class="sd">    :attr:`per_sample_weights`.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_embeddings (int): size of the dictionary of embeddings</span>
<span class="sd">        embedding_dim (int): the size of each embedding vector</span>
<span class="sd">        max_norm (float, optional): If given, each embedding vector with norm larger than :attr:`max_norm`</span>
<span class="sd">                                    is renormalized to have norm :attr:`max_norm`.</span>
<span class="sd">        norm_type (float, optional): The p of the p-norm to compute for the :attr:`max_norm` option. Default ``2``.</span>
<span class="sd">        scale_grad_by_freq (bool, optional): if given, this will scale gradients by the inverse of frequency of</span>
<span class="sd">                                                the words in the mini-batch. Default ``False``.</span>
<span class="sd">                                                Note: this option is not supported when ``mode=&quot;max&quot;``.</span>
<span class="sd">        mode (str, optional): ``&quot;sum&quot;``, ``&quot;mean&quot;`` or ``&quot;max&quot;``. Specifies the way to reduce the bag.</span>
<span class="sd">                                 ``&quot;sum&quot;`` computes the weighted sum, taking :attr:`per_sample_weights`</span>
<span class="sd">                                 into consideration. ``&quot;mean&quot;`` computes the average of the values</span>
<span class="sd">                                 in the bag, ``&quot;max&quot;`` computes the max value over each bag.</span>
<span class="sd">                                 Default: ``&quot;mean&quot;``</span>
<span class="sd">        sparse (bool, optional): if ``True``, gradient w.r.t. :attr:`weight` matrix will be a sparse tensor. See</span>
<span class="sd">                                 Notes for more details regarding sparse gradients. Note: this option is not</span>
<span class="sd">                                 supported when ``mode=&quot;max&quot;``.</span>
<span class="sd">        include_last_offset (bool, optional): if ``True``, :attr:`offsets` has one additional element, where the last element</span>
<span class="sd">                                      is equivalent to the size of `indices`. This matches the CSR format.</span>
<span class="sd">        padding_idx (int, optional): If specified, the entries at :attr:`padding_idx` do not contribute to the</span>
<span class="sd">                                     gradient; therefore, the embedding vector at :attr:`padding_idx` is not updated</span>
<span class="sd">                                     during training, i.e. it remains as a fixed &quot;pad&quot;. For a newly constructed</span>
<span class="sd">                                     EmbeddingBag, the embedding vector at :attr:`padding_idx` will default to all</span>
<span class="sd">                                     zeros, but can be updated to another value to be used as the padding vector.</span>
<span class="sd">                                     Note that the embedding vector at :attr:`padding_idx` is excluded from the</span>
<span class="sd">                                     reduction.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        weight (Tensor): the learnable weights of the module of shape `(num_embeddings, embedding_dim)`</span>
<span class="sd">                         initialized from :math:`\mathcal{N}(0, 1)`.</span>

<span class="sd">    Examples::</span>

<span class="sd">        &gt;&gt;&gt; # an EmbeddingBag module containing 10 tensors of size 3</span>
<span class="sd">        &gt;&gt;&gt; embedding_sum = nn.EmbeddingBag(10, 3, mode=&#39;sum&#39;)</span>
<span class="sd">        &gt;&gt;&gt; # a batch of 2 samples of 4 indices each</span>
<span class="sd">        &gt;&gt;&gt; input = torch.tensor([1, 2, 4, 5, 4, 3, 2, 9], dtype=torch.long)</span>
<span class="sd">        &gt;&gt;&gt; offsets = torch.tensor([0, 4], dtype=torch.long)</span>
<span class="sd">        &gt;&gt;&gt; # xdoctest: +IGNORE_WANT(&quot;non-deterministic&quot;)</span>
<span class="sd">        &gt;&gt;&gt; embedding_sum(input, offsets)</span>
<span class="sd">        tensor([[-0.8861, -5.4350, -0.0523],</span>
<span class="sd">                [ 1.1306, -2.5798, -1.0044]])</span>

<span class="sd">        &gt;&gt;&gt; # Example with padding_idx</span>
<span class="sd">        &gt;&gt;&gt; embedding_sum = nn.EmbeddingBag(10, 3, mode=&#39;sum&#39;, padding_idx=2)</span>
<span class="sd">        &gt;&gt;&gt; input = torch.tensor([2, 2, 2, 2, 4, 3, 2, 9], dtype=torch.long)</span>
<span class="sd">        &gt;&gt;&gt; offsets = torch.tensor([0, 4], dtype=torch.long)</span>
<span class="sd">        &gt;&gt;&gt; embedding_sum(input, offsets)</span>
<span class="sd">        tensor([[ 0.0000,  0.0000,  0.0000],</span>
<span class="sd">                [-0.7082,  3.2145, -2.6251]])</span>

<span class="sd">        &gt;&gt;&gt; # An EmbeddingBag can be loaded from an Embedding like so</span>
<span class="sd">        &gt;&gt;&gt; embedding = nn.Embedding(10, 3, padding_idx=2)</span>
<span class="sd">        &gt;&gt;&gt; embedding_sum = nn.EmbeddingBag.from_pretrained(</span>
<span class="sd">                embedding.weight,</span>
<span class="sd">                padding_idx=embedding.padding_idx,</span>
<span class="sd">                mode=&#39;sum&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__constants__</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;num_embeddings&quot;</span><span class="p">,</span>
        <span class="s2">&quot;embedding_dim&quot;</span><span class="p">,</span>
        <span class="s2">&quot;max_norm&quot;</span><span class="p">,</span>
        <span class="s2">&quot;norm_type&quot;</span><span class="p">,</span>
        <span class="s2">&quot;scale_grad_by_freq&quot;</span><span class="p">,</span>
        <span class="s2">&quot;mode&quot;</span><span class="p">,</span>
        <span class="s2">&quot;sparse&quot;</span><span class="p">,</span>
        <span class="s2">&quot;include_last_offset&quot;</span><span class="p">,</span>
        <span class="s2">&quot;padding_idx&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="n">num_embeddings</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">embedding_dim</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">max_norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="n">norm_type</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">scale_grad_by_freq</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">weight</span><span class="p">:</span> <span class="n">Tensor</span>
    <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">sparse</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">include_last_offset</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">padding_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">num_embeddings</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">embedding_dim</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">max_norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">norm_type</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
        <span class="n">scale_grad_by_freq</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
        <span class="n">sparse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">_weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">include_last_offset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">padding_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">device</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">factory_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;device&quot;</span><span class="p">:</span> <span class="n">device</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">dtype</span><span class="p">}</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_embeddings</span> <span class="o">=</span> <span class="n">num_embeddings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">embedding_dim</span> <span class="o">=</span> <span class="n">embedding_dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_norm</span> <span class="o">=</span> <span class="n">max_norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm_type</span> <span class="o">=</span> <span class="n">norm_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_grad_by_freq</span> <span class="o">=</span> <span class="n">scale_grad_by_freq</span>
        <span class="k">if</span> <span class="n">padding_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">padding_idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">padding_idx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_embeddings</span>
                <span class="p">),</span> <span class="s2">&quot;padding_idx must be within num_embeddings&quot;</span>
            <span class="k">elif</span> <span class="n">padding_idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">padding_idx</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">num_embeddings</span>
                <span class="p">),</span> <span class="s2">&quot;padding_idx must be within num_embeddings&quot;</span>
                <span class="n">padding_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_embeddings</span> <span class="o">+</span> <span class="n">padding_idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding_idx</span> <span class="o">=</span> <span class="n">padding_idx</span>
        <span class="k">if</span> <span class="n">_weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span>
                <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_embeddings</span><span class="p">,</span> <span class="n">embedding_dim</span><span class="p">),</span> <span class="o">**</span><span class="n">factory_kwargs</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset_parameters</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="n">_weight</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span>
                <span class="n">num_embeddings</span><span class="p">,</span>
                <span class="n">embedding_dim</span><span class="p">,</span>
            <span class="p">],</span> <span class="s2">&quot;Shape of weight does not match num_embeddings and embedding_dim&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weight</span> <span class="o">=</span> <span class="n">Parameter</span><span class="p">(</span><span class="n">_weight</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span> <span class="o">=</span> <span class="n">sparse</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_last_offset</span> <span class="o">=</span> <span class="n">include_last_offset</span>

    <span class="k">def</span> <span class="nf">reset_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">init</span><span class="o">.</span><span class="n">normal_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fill_padding_idx_with_zero</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_fill_padding_idx_with_zero</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">torch</span><span class="o">.</span><span class="n">no_grad</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">padding_idx</span><span class="p">]</span><span class="o">.</span><span class="n">fill_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="nb">input</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">offsets</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">per_sample_weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Forward pass of EmbeddingBag.</span>

<span class="sd">        Args:</span>
<span class="sd">            input (Tensor): Tensor containing bags of indices into the embedding matrix.</span>
<span class="sd">            offsets (Tensor, optional): Only used when :attr:`input` is 1D. :attr:`offsets` determines</span>
<span class="sd">                the starting index position of each bag (sequence) in :attr:`input`.</span>
<span class="sd">            per_sample_weights (Tensor, optional): a tensor of float / double weights, or None</span>
<span class="sd">                to indicate all weights should be taken to be ``1``. If specified, :attr:`per_sample_weights`</span>
<span class="sd">                must have exactly the same shape as input and is treated as having the same</span>
<span class="sd">                :attr:`offsets`, if those are not ``None``. Only supported for ``mode=&#39;sum&#39;``.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tensor output shape of `(B, embedding_dim)`.</span>

<span class="sd">        .. note::</span>

<span class="sd">            A few notes about ``input`` and ``offsets``:</span>

<span class="sd">            - :attr:`input` and :attr:`offsets` have to be of the same type, either int or long</span>

<span class="sd">            - If :attr:`input` is 2D of shape `(B, N)`, it will be treated as ``B`` bags (sequences)</span>
<span class="sd">              each of fixed length ``N``, and this will return ``B`` values aggregated in a way</span>
<span class="sd">              depending on the :attr:`mode`. :attr:`offsets` is ignored and required to be ``None`` in this case.</span>

<span class="sd">            - If :attr:`input` is 1D of shape `(N)`, it will be treated as a concatenation of</span>
<span class="sd">              multiple bags (sequences).  :attr:`offsets` is required to be a 1D tensor containing the</span>
<span class="sd">              starting index positions of each bag in :attr:`input`. Therefore, for :attr:`offsets` of shape `(B)`,</span>
<span class="sd">              :attr:`input` will be viewed as having ``B`` bags. Empty bags (i.e., having 0-length) will have</span>
<span class="sd">              returned vectors filled by zeros.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">F</span><span class="o">.</span><span class="n">embedding_bag</span><span class="p">(</span>
            <span class="nb">input</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span>
            <span class="n">offsets</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_norm</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm_type</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale_grad_by_freq</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sparse</span><span class="p">,</span>
            <span class="n">per_sample_weights</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">include_last_offset</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">padding_idx</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">extra_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{num_embeddings}</span><span class="s2">, </span><span class="si">{embedding_dim}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, max_norm=</span><span class="si">{max_norm}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_type</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, norm_type=</span><span class="si">{norm_type}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale_grad_by_freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, scale_grad_by_freq=</span><span class="si">{scale_grad_by_freq}</span><span class="s2">&quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, mode=</span><span class="si">{mode}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;, padding_idx=</span><span class="si">{padding_idx}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">repr</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_pretrained</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">embeddings</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">freeze</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">max_norm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">norm_type</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
        <span class="n">scale_grad_by_freq</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
        <span class="n">sparse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">include_last_offset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">padding_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;EmbeddingBag&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Create EmbeddingBag instance from given 2-dimensional FloatTensor.</span>

<span class="sd">        Args:</span>
<span class="sd">            embeddings (Tensor): FloatTensor containing weights for the EmbeddingBag.</span>
<span class="sd">                First dimension is being passed to EmbeddingBag as &#39;num_embeddings&#39;, second as &#39;embedding_dim&#39;.</span>
<span class="sd">            freeze (bool, optional): If ``True``, the tensor does not get updated in the learning process.</span>
<span class="sd">                Equivalent to ``embeddingbag.weight.requires_grad = False``. Default: ``True``</span>
<span class="sd">            max_norm (float, optional): See module initialization documentation. Default: ``None``</span>
<span class="sd">            norm_type (float, optional): See module initialization documentation. Default ``2``.</span>
<span class="sd">            scale_grad_by_freq (bool, optional): See module initialization documentation. Default ``False``.</span>
<span class="sd">            mode (str, optional): See module initialization documentation. Default: ``&quot;mean&quot;``</span>
<span class="sd">            sparse (bool, optional): See module initialization documentation. Default: ``False``.</span>
<span class="sd">            include_last_offset (bool, optional): See module initialization documentation. Default: ``False``.</span>
<span class="sd">            padding_idx (int, optional): See module initialization documentation. Default: ``None``.</span>

<span class="sd">        Examples::</span>

<span class="sd">            &gt;&gt;&gt; # FloatTensor containing pretrained weights</span>
<span class="sd">            &gt;&gt;&gt; weight = torch.FloatTensor([[1, 2.3, 3], [4, 5.1, 6.3]])</span>
<span class="sd">            &gt;&gt;&gt; embeddingbag = nn.EmbeddingBag.from_pretrained(weight)</span>
<span class="sd">            &gt;&gt;&gt; # Get embeddings for index 1</span>
<span class="sd">            &gt;&gt;&gt; input = torch.LongTensor([[1, 0]])</span>
<span class="sd">            &gt;&gt;&gt; # xdoctest: +IGNORE_WANT(&quot;non-deterministic&quot;)</span>
<span class="sd">            &gt;&gt;&gt; embeddingbag(input)</span>
<span class="sd">            tensor([[ 2.5000,  3.7000,  4.6500]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">embeddings</span><span class="o">.</span><span class="n">dim</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="p">),</span> <span class="s2">&quot;Embeddings parameter is expected to be 2-dimensional&quot;</span>
        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">embeddings</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">embeddingbag</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">num_embeddings</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span>
            <span class="n">embedding_dim</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span>
            <span class="n">_weight</span><span class="o">=</span><span class="n">embeddings</span><span class="p">,</span>
            <span class="n">max_norm</span><span class="o">=</span><span class="n">max_norm</span><span class="p">,</span>
            <span class="n">norm_type</span><span class="o">=</span><span class="n">norm_type</span><span class="p">,</span>
            <span class="n">scale_grad_by_freq</span><span class="o">=</span><span class="n">scale_grad_by_freq</span><span class="p">,</span>
            <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span>
            <span class="n">sparse</span><span class="o">=</span><span class="n">sparse</span><span class="p">,</span>
            <span class="n">include_last_offset</span><span class="o">=</span><span class="n">include_last_offset</span><span class="p">,</span>
            <span class="n">padding_idx</span><span class="o">=</span><span class="n">padding_idx</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">embeddingbag</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">requires_grad</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">freeze</span>
        <span class="k">return</span> <span class="n">embeddingbag</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright (c) 2023 Graphcore Ltd. All rights reserved.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>